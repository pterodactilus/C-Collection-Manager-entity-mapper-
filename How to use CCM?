//How to use this?

//First you should add to your code necessary namespaces. 

using System; 
using System.Collections; 
using System.Collections.Generic; 
using CS_Collections_Mapper; 

Define mapper and sqlManager

//Storing instances of mapper and SqlManager in singletone Repository class. 

ICollectionManager mapper = Repository.Mapper;
ISQLManager sqlManager = Repository.TsqlManager;

//How to connect to DB 

//ISQLManager interface has several methods to establish the connection to data base. You should to create connection before you make any operations with mapper or sqlManager. Here they are: 

//Add connections methods 

string GetConfigPath(string pathKey, string configName, string subFolder) 
void AddConnection(string connAlias, string connectionString) 
void AddDefaultConfigConnections() 
void AddCustomConfigConnections(string configPath) 

//Get connections methods 

string GetConnectionStringByAlias(string connAlias) 
Dictionary GetConnections() 

//Remove connections methods 

void RemoveConnection(string connAlias) 
void RemoveConnections() 

If your application is of classic .Net Framework type, you can use connection strings defined in web.config or app.config files. In this case call the 

AddDefaultConfigConnections() method. 

After this you can use connection aliases to pass it as a parameter to call mapper or sqlManager to operate with DB. You may have additional config files in application folders.

If this files contains ConnectionStrings sections the connections may be added to connection collection of sqlManager and you can use it by its alias. 

To add this connections call the AddCustomConfigConnections(string configPath) method, where configPath a phisical path to custom config file. 
To get and pass the path for this config file to AddCustomConfigConnections method call the GetConfigPath(string pathKey, string configName, string subFolder) method with configName and subFolder parameters with empty pathKey parameter. 

Or call GetConfigPath(string pathKey, string configName, string subFolder) with config key pathKey with physical path from app.config or web.config files and empty configName and subFolder parameters. 
You can add connections manually by calling the AddConnection(string connAlias, string connectionString) method. This may be usefull if you have no config files in application, e.g. if your application is of .Net Core type. 
Also you can get, check and remove connections by calling GetConnectionStringByAlias(string connAlias) and RemoveConnection(string connAlias) methods.

Example of how to get the collection

public ICollection<Book> GetBooks(string connAlias, Guid creatorID) 
{

    Hashtable parameters = new Hashtable();
    parameters["@CreatorID"] = creatorID;


    return mapper.GetCollection<Book> 
    ( 
        Repository.AllBooks,          // destination collection 
        "GetTestBooks",                // Stored procedure name 
        connAlias,                         // connection string alias(defined in config) 
        parameters,                      // Stored procedure parameters 
        true                                 // *see explanation below 
    ); 
}

Pay attention to the last boolean "true" parameter in the GetCollection method. His presence obliges to transfer to the entity class constructor a data reader. Overloaded constructor recieve entity Id only. See entity Book class example.

If this boolean is set to true the @ReturnAtOnce parameter is passed to the SQL procedure, then the procedure returns the entire record set in one pass with all the entity fields. If this parameter is omitted or set to false, then by default the procedure is called two times - first time to get all the list of entities IDs, and then, when creating every instance of the class is called again, already with the existing ID parameter to get all the fields of the instance with the given ID. It is usefull for calculate comlex entity fields with secondary queries. 

Example of an element retrieval method from collection (Book instance)
If instance with this Id not present in collection, it will be added to collection from db table 


public Book GetBook(int bookId, ICollection<Book> collection) 
{ 
    return mapper.GetCollectionItem<Book>(collection, bookId); 
}

Example for update method of collection instance

While updating, item instance will be deleted and recreated in collection with new one. The position of new instance in collection will not changed and remain the same. If instance with item Id is not present in collection, it will NOT be added to collection and no action will perform.

public void UpdateBook(int bookID) 
{ 
    mapper.UpdateCollectionItem(Repository.UserBooks, bookID); 
}

Example for delete from database table.

You should create procedure for delete row from table (if it is still not present in database) 

Create PROCEDURE [dbo].[DeleteBooks] @BookID int AS 

IF @BookID is not null 
-- delete specific book 
    Delete FROM Books 
    WHERE (BookID = @BookID) 
RETURN

Calling this stored procedure

Hashtable parameters = new Hashtable(); 
parameters["@BookID"] = bookID; 
string errMsg = string.Empty; 
sqlManager.ExecuteNonQuery("CmsDb", "DeleteBooks", parameters, out errMsg);

If you have changed the database tables on base of which the collection was built, you may need to update collection with its items. Now we remove instance from collection for deleted table row. 

Example for remove instance 

public void RemoveBook(int bookID, ICollection<Book>collection)
{
    mapper.RemoveCollectionItem(collection, bookID);
}

The same action (more simple and quickly)

Repository.UserBooks.Remove(book);

If you have to change one or two items you may use mapper.UpdateCollectionItem method. But if you source tables have changed significally the better way is to recreate the whole collection one more time. For this purpose you should to clear collection(optional) and refill it with renewed instances.

Use the collection.Clear() and mapper.GetCollection() methods.

Example implementation of an entity class 

public class Book : Sortable 
{ 
    public int BookID { get; set; } 
    public double Rating { get; set; } 
    public DateTime DateCreation { get; set; } 
    public string Caption { get; set; } 
    public Guid CreatorID { get; set; } 
    public bool Published { get; set; } 

    public Book() 
    { 
    } 
    
    public Book(IDataReader reader, int sortID) : base(reader, sortID) 
    { 
    } 


You should specify the entity key field in collection constructor (not in the entity class) to tell mapper what is the key of entity in collection. It may have any name. Public field BookID in example above is differs from the default ID name. For convinence the key field may have the same name as primary key field or it alias, returned by stored procedure.

The BookID variable in constructor below is a stored procedure key parameter for seek the row in the Books table. It may have the same name as a class key field name but in this constructor definition it means another thing. You can omit this parameter if the Get stored procedure input key parameter named as "ID". The key parameter in GetTestBooks procedure has the name BookID, that is why we should point it also in a constructor signature. 


    public Book(int id_key, int sortID) : base(id_key, sortID, "CmsDb", "GetTestBooks", "BookID") 
    { 
    }

    // the set of fields relevant for the entity is defined in the procedure 

    public override void MapEntityFields(IDataReader reader, int sortID) 
   { 
       // automatically filling entity fields that has the same names as reader returns 

       AutoMapEntity(reader, typeof(Book), this, sortID);

        try 
        {
            // filling entity fields manually. works faster than AutoMapEntityFields
            // but require more code. here we can process data transformations

            CreatorID = Guid.Parse(reader["CreatorID"].ToString()); 

        } 
        catch (Exception ex) 
        { 
        } 
    }
} 

All work with the data is reduced to writing the simple stored procedures for each entity and to create classes describing collections and methods for operations with them (storage, retrieval, modification) 

SQL stored procedure to get Books data

Create PROCEDURE [dbo].[GetTestBooks] 
@CreatorID nvarchar(50) = null, 
@BookID int = null, 
@ReturnAtOnce bit = null 

AS 

IF @BookID is not null 
    
    -- specific book 
        SELECT BookID, Caption, CreatorID, DateCreation, PhotoID, Published, Position, Modified, 
        Rating, ForeignBook, TextID 
        FROM Books 
        WHERE (BookID = @BookID) 

ELSE IF @CreatorID is not null 
    
    -- user books 
    begin 
        if @ReturnAtOnce is not null 
            SELECT BookID, Caption, CreatorID, DateCreation, PhotoID, Published, 
            Position, Modified, Rating, ForeignBook, TextID 
            FROM Books 
            WHERE (CreatorID = @CreatorID) 
        else 
            SELECT BookID 
            FROM Books 
            WHERE (CreatorID = @CreatorID)

            ORDER BY DateCreation DESC 
    end 

ELSE 

    -- all books 
    begin 
        if @ReturnAtOnce is not null 
            SELECT BookID, Caption, CreatorID, DateCreation, PhotoID, Published, 
            Position, Modified, Rating, ForeignBook, TextID 
            FROM Books 
            ORDER BY DateCreation DESC
        else 
            SELECT BookID FROM Books 
            ORDER BY DateCreation DESC
    end 
RETURN

We may build any amount of collections with the same prototype entity class where the base class being used is the same. In the examples below, two different collections are used. It is important to note that instances of one collection we get from another. With such approach we did not store the same instances in memory and did not pull the same data from SQL server for several times.

For example, we have a store of books and it is divided into several shelfs. In one shelf is books for sale, and in other shelfs books for reading. If you put a book in the wrong shelf (e.g. in BooksList collection), someone will be surprised with pleasure, and someone will loss it. In the store there will remain the changeless amount of books and it does not change (we operate only with links to instances).

It is important that in all shelfs there are only books and between them are no principal different. My books I take from the shelf for reading. On this shelf books fall from the store (heaps). 
If I have read all my books, I can go to the store (to the heap) and take another books for reading, or I can order the new ones if they not exists in the store (create new instanses in collection).

Declare collections classes

UserBooksList collection stored in the heap Repository.AllBooks 

public class UserBooks : BooksHeap 
{ 
    public UserBooks() 
    {

        // indicates that UserBooks instances are stored in the heap
        heapCollection = Repository.AllBooks; 
    } 
}

Here it should be clarified that there is an overrided method in the CollectionManager that uses a constructor with two IDs. This is may be necessary in case if the procedure on the server collects records from different data sources. For example, the SecondID parameter defines the table, the data from which merged into the resulting query. Then an instance in the collection is searched by two id (in fact, this is a two-dimensional array with two keys)

The heap collection class (prototype) 

public class BooksHeap : BaseCollection<Book> 
{ 
    // heap declaration class 
    public BooksHeap() 
    { 
        // Specify the collection field ID
        idFieldName = "BookID"; 
    } 
}

Storing collections in Repository


// AllBooks is the heap from which the UserBooks collection is compiled
private static ICollection<Book>_AllBooks; 
public static ICollection<Book>AllBooks 
{ 
    get 
    { 
        return _AllBooks ?? (_AllBooks = new BooksHeap() as ICollection<Book>); 
    } 
    set 
    { 
        _AllBooks = value; 
    } 
} 

private static ICollection<Book>_UserBooks; 
public static ICollection<Book>UserBooks 
{ 
    get 
    { 
        return _UserBooks ?? (_UserBooks = new UserBooks() as ICollection<Book>); 
    } 
    set 
    { 
        _UserBooks = value; 
    } 
}

Example of how to build a two-dimensional collection.

Here Somethings2 is a collection in which we search desired instance 

public static void CopySomethings() 
{ 
    foreach (Something something in Somethings) 
    { 
        int somethingID = something.SomethingID; 
        int ID2 = something.SecondID; 
        Something something2 = (Something)CollectionManager.GetCollectionItem( 
        Somethings2, somethingID, ID2); 
    } 
}

Initial filling of collections with elements

If we omit the last optional bool parameter in the mapper.GetCollection call, mapper get instance from database by two passes. At first the stored procedure pulls out a list of entity IDs by which instances are searched for in collection or created new ones. In this case, the method is universal for all collections, including the Heap. 

After receiving the id, the CollectionManager looking for the instance with this Id in collection. If the instance is already in the collection, mapper returns the collections instance of this entity type with this Id. And if he is not exists there called entity's constructor and the new item is added to the collection from database.

If in the database the data source has changed (for example, the table has been updated), you should to update the corresponding instance of the collection. When the entity instance updates it removed from the collection, re-created and inserted there, where he was (sorting by ID).In UpdateCollectionItem method if no such item were found in the collection, it will not be added (!)

For delete, create and update records in the database tables use SqlManager class.

Examples of using SqlManager library. Calling stored procedure for execute (e.g. add new Book to database). You can call it by using 

sqlManager.ExecuteNonQuery(dbAlias, procName, parameters, out errMsg); 

or with retrieving some results from procedure

sqlManager.SQLExecuteScalar(dbAlias, procName, parameters)

Example for create stored procedure to add new books

Create PROCEDURE [dbo].[AddBook] 
@Caption nvarchar(100), 
@CreatorID nvarchar(50) 

AS 

Declare @Position int 
SELECT @Position = Count(Books.BookID) + 1 
FROM Books 
WHERE Books.CreatorID = @CreatorID 

INSERT INTO Books (Caption, PhotoID, CreatorID, Published, DateCreation, 
Position, Modified, Rating, TextID) 
VALUES (@Caption, 0, @CreatorID, 0, GetDate(), @Position, GetDate(), 0, 0) 

Select scope_identity() AS NEW_BookID 
RETURN

and how to execute it

Hashtable parameters = new Hashtable(); 
parameters["@Caption"] = "My new book"; 
parameters["@CreatorID"] = Guid.NewGuid(); 
int newBookId = -1; 

try 
{ 
    Int32.TryParse(sqlManager.SQLExecuteScalar("CmsDb", "AddBook", parameters).ToString(), out newBookId); 
} 
catch (Exception ex) 
{ 
} 

if (newBookId > 0) 
{ 
    // some actions with newBookId 
}

For some reasons we may need to execute stored procedure and retrieve output value from it. Getting output parameter from stored procedure (e.g. int, or XML as output value(s)).You can call SQLExecuteScalar for retrieve array of output parameters returned by stored procedure. For this you should add them to separate Hashtable. 

int myInt = -1; 
XmlDocument xd = new XmlDocument() 
string outputMessage = string.Empty; 

Hashtable outputParameters = new Hashtable(); 
outputParameters["@someIntResult"] = myInt; 
outputParameters["@someXMLResult"] = xd; 
outputParameters["@someStringResult"] = outputMessage; 

Hashtable inputParameters = new Hashtable(); 
inputParameters["@Published"] = true; 
object[] result = sqlManager.SQLExecuteScalar("CmsDb", "GetAuthors", inputParameters, outputParameters);

Thats all for today. The approach described here is successfully used on the web sites prozarium.ru, in the PGMania program and other projects and showed the best performance results.
